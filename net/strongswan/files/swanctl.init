#!/bin/sh /etc/rc.common

START=90
STOP=10

USE_PROCD=1
PROG=/usr/lib/ipsec/charon

. $IPKG_INSTROOT/lib/functions.sh
. $IPKG_INSTROOT/lib/functions/network.sh

STRONGSWAN_CONF_FILE=/etc/strongswan.conf
STRONGSWAN_VAR_CONF_FILE=/var/ipsec/strongswan.conf

SWANCTL_CONF_FILE=/etc/swanctl/swanctl.conf
SWANCTL_VAR_CONF_FILE=/var/swanctl/swanctl.conf

WAIT_FOR_INTF=0

CONFIG_FAIL=0

time2seconds()
{
	local timestring="$1"
	local multiplier number suffix

	suffix="${timestring//[0-9 ]}"
	number="${timestring%%$suffix}"
	[ "$number$suffix" != "$timestring" ] && return 1
	case "$suffix" in
	""|s)
		multiplier=1 ;;
	m)
		multiplier=60 ;;
	h)
		multiplier=3600 ;;
	d)
		multiplier=86400 ;;
	*)
		return 1 ;;
	esac
	echo $(( number * multiplier ))
}

seconds2time()
{
	local seconds="$1"

	if [ $seconds -eq 0 ]; then
		echo "0s"
	elif [ $((seconds % 86400)) -eq 0 ]; then
		echo "$((seconds / 86400))d"
	elif [ $((seconds % 3600)) -eq 0 ]; then
		echo "$((seconds / 3600))h"
	elif [ $((seconds % 60)) -eq 0 ]; then
		echo "$((seconds / 60))m"
	else
		echo "${seconds}s"
	fi
}

file_reset() {
	: > "$1"
}

xappend() {
	local file="$1"
	shift

	echo "$@" >> "$file"
}

add_spaces() {
        [ $1 -eq 0 ] && return
        for i in $(seq 1 $1); do
                with_spaces="  $with_spaces";
        done
}

swan_reset() {
	file_reset "$STRONGSWAN_VAR_CONF_FILE"
}

swan_xappend() {
	local c="$1"
        shift
        local with_spaces="$@"
        add_spaces $c
	xappend "$STRONGSWAN_VAR_CONF_FILE" "$with_spaces"
}

swanctl_reset() {
	file_reset "$SWANCTL_VAR_CONF_FILE"
}

swanctl_xappend() {
	local c="$1"
        shift
        local with_spaces="$@"
        add_spaces $c
	xappend "$SWANCTL_VAR_CONF_FILE" "$with_spaces"
}

# swanctl_xappend_cfg <indent> <section> <option> [<default>]
swanctl_xappend_cfg() {
	local cfgval
	config_get cfgval "$2" $3 "$4"
	[ -n "$cfgval" ] swanctl_xappend $1 "$3 = $cfgval"
}

# swanctl_xappend_var <indent> <varname>
swanctl_xappend_var() {
	local varval
	eval "varval=\"\$$2\""
	[ -n "$varval" -a "$varval" != "\"\"" ] && swanctl_xappend $1 "$2 = $varval"
}

# swanctl_xappend_opt <indent> <option_name> <value>
swanctl_xappend_opt() {
	local indent="$1"
	local option="$2"
	shift
	shift
	[ -n "$@" -a "$@" != "\"\"" ] && swanctl_xappend $indent "$option = $@"
}

warning() {
	echo "WARNING: $@" >&2
}

fatal() {
	echo "ERROR: $@" >&2
	CONFIG_FAIL=1
}

is_aead() {
	local cipher="$1"

	case "$cipher" in
	aes*gcm*|aes*ccm*|aes*gmac*)
		return 0 ;;
	chacha20poly1305)
		return 0 ;;
	esac

	return 1
}

add_esp_proposal() {
	local encryption_algorithm
	local hash_algorithm
	local dh_group

	config_get encryption_algorithm "$1" encryption_algorithm
	config_get hash_algorithm "$1" hash_algorithm
	config_get dh_group "$1" dh_group

	# check for AEAD and clobber hash_algorithm if set
	if is_aead "$encryption_algorithm" && [ -n "$hash_algorithm" ]; then
		fatal "Can't have $hash_algorithm with $encryption_algorithm"
		hash_algorithm=
	fi

	[ -n "$encryption_algorithm" ] && \
		crypto="${crypto:+${crypto},}${encryption_algorithm}${hash_algorithm:+-${hash_algorithm}}${dh_group:+-${dh_group}}"
}

parse_esp_proposal() {
	local conf="$1"
	local var="$2"

	local crypto=""

	config_list_foreach "$conf" crypto_proposal add_esp_proposal

	export -n "$var=$crypto"
}

add_ike_proposal() {
	local encryption_algorithm
	local hash_algorithm
	local dh_group
	local prf_algorithm

	config_get encryption_algorithm "$1" encryption_algorithm
	config_get hash_algorithm "$1" hash_algorithm
	config_get dh_group "$1" dh_group
	config_get prf_algorithm "$1" prf_algorithm

	# check for AEAD and clobber hash_algorithm if set
	if is_aead "$encryption_algorithm" && [ -n "$hash_algorithm" ]; then
		fatal "Can't have $hash_algorithm with $encryption_algorithm"
		hash_algorithm=
	fi

	[ -n "$encryption_algorithm" ] && \
		crypto="${crypto:+${crypto},}${encryption_algorithm}${hash_algorithm:+-${hash_algorithm}}${prf_algorithm:+-${prf_algorithm}}${dh_group:+-${dh_group}}"
}

parse_ike_proposal() {
	local conf="$1"
	local var="$2"

	local crypto=""

	config_list_foreach "$conf" crypto_proposal add_ike_proposal

	export -n "$var=$crypto"
}

config_conn() {
	# Generic ipsec conn section shared by tunnel and transport
	local config_name="$1"
	local mode="$2"

	local local_ts
	local remote_ts
	local local_nat
	local firewall
	local life_time
	local dpd_action
	local close_action
	local start_action
	local if_id
	local rekey_time

	config_get start_action "$1" startaction "route"
	config_get local_ts "$1" local_subnet ""
	config_get local_nat "$1" local_nat ""
	config_get firewall "$1" firewall ""
	config_get remote_ts "$1" remote_subnet ""
	config_get life_time "$1" lifetime ""
	config_get dpd_action "$1" dpdaction "none"
	config_get close_action "$1" closeaction "none"
	config_get if_id "$1" if_id ""
	config_get rekey_time "$1" rekeytime ""

	local esp_proposals
	parse_esp_proposal "$1" esp_proposals

	# translate from ipsec to swanctl
	case "$start_action" in
	add)
		start_action="none" ;;
	route)
		start_action="trap" ;;
	start|none|trap)
		# already using new syntax
		;;
	*)
		fatal "Startaction $start_action unknown"
		start_action=
		;;
	esac

	case "$close_action" in
	none|clear)
		close_action="none" ;;
	hold)
		close_action="trap" ;;
	restart)
		close_action="start" ;;
	trap|start)
		# already using new syntax
		;;
	*)
		fatal "Closeaction $close_action unknown"
		close_action=
		;;
	esac

	[ -n "$close_action" -a "$close_action" != "none" ] && warning "Closeaction $close_action can cause instability"

	case "$dpd_action" in
	none)
		dpddelay="0s"
		dpd_action=
		;;
	clear)
		;;
	hold)
		dpd_action="trap" ;;
	restart)
		dpd_action="start" ;;
	trap|start)
		# already using new syntax
		;;
	*)
		fatal "Dpdaction $dpd_action unknown"
		dpd_action=
		;;
	esac

	[ -n "$local_nat" ] && local_ts="$local_nat"

	swanctl_xappend 3 "$config_name {"

	swanctl_xappend_var 4 local_ts
	swanctl_xappend_var 4 remote_ts
	swanctl_xappend_opt 4 if_id_in "$if_id"
	swanctl_xappend_opt 4 if_id_out "$if_id"
	[ "$start_action" != "none" ] && swanctl_xappend_var 4 start_action
	[ "$close_action" != "none" ] && swanctl_xappend_var 4 close_action
	swanctl_xappend_var 4 esp_proposals
	swanctl_xappend_var 4 mode

	if [ -n "$life_time" ]; then
		swanctl_xappend_var 4 life_time
	elif [ -n "$rekey_time" ]; then
		swanctl_xappend_opt 4 life_time "$(seconds2time $(((110 * $(time2seconds $rekey_time)) / 100)))"
	fi
	swanctl_xappend_var 4 rekey_time
	swanctl_xappend_cfg 4 "$1" inactivity

	swanctl_xappend_cfg 4 "$1" updown
	swanctl_xappend_var 4 dpd_action

        swanctl_xappend 3 "}"
}

config_tunnel() {
	config_conn "$1" "tunnel"
}

config_transport() {
	config_conn "$1" "transport"
}

config_remote() {
	local config_name="$1"

	local enabled
	local gateway
	local local_gateway
	local local_sourceip
	local local_leftip
	local remote_gateway
	local secret
	local auth
	local keyingtries
	local dpddelay
	local inactivity
	local keyexchange
	local fragmentation
	local mobike
	local local_cert
	local local_key
	local ca_cert
	local rekey_time

	config_get_bool enabled "$1" enabled 0
	[ $enabled -eq 0 ] && return

	config_get gateway "$1" gateway
	config_get secret "$1" pre_shared_key
	config_get auth "$1" authentication_method
	config_get local_identifier "$1" local_identifier ""
	config_get remote_identifier "$1" remote_identifier ""
	config_get local_sourceip "$1" local_sourceip ""
	config_get local_leftip "$1" local_leftip "%any"
	config_get keyingtries "$1" keyingtries "3"
	config_get dpd_delay "$1" dpddelay "30s"
	config_get inactivity "$1" inactivity
	config_get keyexchange "$1" keyexchange "ikev2"
	config_get fragmentation "$1" fragmentation "yes"
	config_get_bool mobike "$1" mobike 1
	config_get local_cert "$1" local_cert ""
	config_get local_key "$1" local_key ""
	config_get ca_cert "$1" ca_cert ""
	config_get rekey_time "$1" rekeytime
	config_get over_time "$1" overtime

	case "$fragmentation" in
	0)
		fragmentation="no" ;;
	1)
		fragmentation="yes" ;;
	yes|accept|force|no)
		# already using new syntax
		;;
	*)
		fatal "Fragmentation $fragmentation not supported"
		fragmentation=
		;;
	esac

	[ "$gateway" = "any" ] && remote_gateway="%any" || remote_gateway="$gateway"

	[ -z "$local_gateway" ] && {
		local ipdest

		[ "$remote_gateway" = "%any" ] && ipdest="1.1.1.1" || ipdest="$remote_gateway"
		local_gateway=`ip -o route get $ipdest | awk '/ src / { gsub(/^.* src /,""); gsub(/ .*$/, ""); print $0}'`
	}

	local proposals
	parse_ike_proposal "$1" proposals

	[ -n "$firewall" ] && fatal "Firewall not supported"

	swanctl_xappend 0 "# config for $config_name"
	swanctl_xappend 0 "connections {"
	swanctl_xappend 1 "$config_name {"
	swanctl_xappend_opt 2 local_addrs "$local_leftip"
	swanctl_xappend_opt 2 remote_addrs "$remote_gateway"

	swanctl_xappend_opt 2 vips "$local_sourceip"
	swanctl_xappend_opt 2 fragmentation "$fragmentation"

	swanctl_xappend 2 "local {"
	swanctl_xappend_var 3 auth

	swanctl_xappend_opt 3 local_identifier "\"$local_identifier\""
	[ "$auth" = pubkey ] && swanctl_xappend_opt 3 certs "$local_cert"
	swanctl_xappend 2 "}"

	swanctl_xappend 2 "remote {"
	swanctl_xappend_var 3 auth
	swanctl_xappend_opt 3 remote_identifier "\"$remote_identifier\""
	swanctl_xappend 2 "}"

	swanctl_xappend 2 "children {"

	config_list_foreach "$1" tunnel config_tunnel

	config_list_foreach "$1" transport config_transport

	swanctl_xappend 2 "}"

	case "$keyexchange" in
	ike)
		;;
	ikev1)
		swanctl_xappend_opt 2 version 1 ;;
	ikev2)
		swanctl_xappend_opt 2 version 2 ;;
	*)
		fatal "Keyexchange $keyexchange not supported"
		keyexchange=
		;;
	esac

	[ $mobike -eq 1 ] && swanctl_xappend_opt 2 mobike yes || swanctl_xappend_opt 2 mobike no

	if [ -n "$rekey_time" ]; then
		swanctl_xappend_var 2 rekey_time

		if [ -z "$over_time" ]; then
			over_time=$(seconds2time $(($(time2seconds $rekey_time) / 10)))
		fi
	fi
	swanctl_xappend_var 2 over_time

	swanctl_xappend_var 2 proposals
	swanctl_xappend_var 2 dpd_delay

	[ "$keyingtries" = "%forever" ] && keyingtries=0
	swanctl_xappend_var 2 keyingtries

	swanctl_xappend 1 "}"
	swanctl_xappend 0 "}"

	if [ "$auth_method" = pubkey ]; then
		swanctl_xappend 0 ""

		swanctl_xappend 0 "secrets {"
		swanctl_xappend 1 "rsa {"
		swanctl_xappend_opt 2 filename "$local_key"
		swanctl_xappend 1 "}"
		swanctl_xappend 0 "}"

		swanctl_xappend 0 ""

		if [ -n "$ca_cert" ]; then
			swanctl_xappend 0 "authorities {"
			swanctl_xappend 1 "$config_name {"
			swanctl_xappend_var ca_cert
			swanctl_xappend 1 "}"
			swanctl_xappend 0 "}"
		fi

	elif [ "$auth_method" = psk ]; then
		swanctl_xappend 0 ""

		swanctl_xappend 0 "secrets {"
		swanctl_xappend 1 "ike {"
		swanctl_xappend_var 2 secret
		if [ -n "$local_id" ]; then
			swanctl_xappend_opt 2 id1 "$local_id"
			if [ -n "$remote_id" ]; then
				swanctl_xappend_opt 2 id2 "$remote_id"
			fi
		fi
		swanctl_xappend 1 "}"
		swanctl_xappend 0 "}"
	else
		fatal "AuthenticationMode $auth_mode not supported"
	fi

	swanctl_xappend 0 ""
}

do_preamble() {
	swanctl_xappend 0 "# generated by /etc/init.d/swanctl"
}

append_interface() {
	append interface_list "$1" " "
}

config_ipsec() {
	local rtinstall_enabled
	local routing_table
	local routing_table_id
	local interface

	config_get debug "$1" debug 0
	config_get_bool rtinstall_enabled "$1" rtinstall_enabled 1
	[ $rtinstall_enabled -eq 1 ] && install_routes=yes || install_routes=no

	# prepare extra charon config option ignore_routing_tables
	for routing_table in $(config_get "$1" "ignore_routing_tables"); do
		if [ "$routing_table" -ge 0 ] 2>/dev/null; then
			routing_table_id=$routing_table
		else
			routing_table_id=$(sed -n '/[ \t]*[0-9]\+[ \t]\+'$routing_table'[ \t]*$/s/[ \t]*\([0-9]\+\).*/\1/p' /etc/iproute2/rt_tables)
		fi

		[ -n "$routing_table_id" ] && append routing_tables_ignored "$routing_table_id"
	done

	local interface_list
	config_list_foreach "$1" interface append_interface

	if [ -z "$interface_list" ]; then
		WAIT_FOR_INTF=0
	else
		for interface in $interface_list; do
			network_get_device device $interface
			[ -n "$device" ] && append device_list "$device" ","
		done
		[ -n "$device_list" ] && WAIT_FOR_INTF=0 || WAIT_FOR_INTF=1
	fi
}

do_postamble() {
	swan_xappend 0 "# generated by /etc/init.d/swanctl"
	swan_xappend 0 "charon {"
	swan_xappend 1 "install_routes = $install_routes"
	[ -n "$routing_tables_ignored" ] && swan_xappend 1 "ignore_routing_tables = $routing_tables_ignored"
	[ -n "$device_list" ] && swan_xappend 1 "interfaces_use = $device_list"
	swan_xappend 1 "start-scripts {"
	swan_xappend 2 "load-all = /usr/sbin/swanctl --load-all --noprompt"
	swan_xappend 1 "}"
	swan_xappend 1 "syslog {"
	swan_xappend 2 "identifier = ipsec"
	swan_xappend 2 "daemon {"
	swan_xappend 3 "default = $debug"
	swan_xappend 2 "}"
	swan_xappend 1 "}"
	swan_xappend 0 "}"
}

prepare_env() {
	mkdir -p /var/ipsec /var/swanctl

	swan_reset
	swanctl_reset
	do_preamble

	# needed by do_postamble
	local debug install_routes routing_tables_ignored device_list

	config_load ipsec
	config_foreach config_ipsec ipsec
	config_foreach config_remote remote

	do_postamble
}

service_running() {
	swanctl --stats > /dev/null 2>&1
}

reload_service() {
	running && {
		prepare_env
		[ $WAIT_FOR_INTF -eq 0 ] && {
			swanctl --load-all --noprompt
			return
		}
	}

	start
}

stop_service() {
	swan_reset
	swanctl_reset
}

service_triggers() {
	procd_add_reload_trigger "ipsec"
	config load "ipsec"
}

start_service() {
	prepare_env

	[ $WAIT_FOR_INTF -eq 1 ] && return

	if [ $CONFIG_FAIL -ne 0 ]; then
		procd_set_param error "Invalid configuration"
		return
	fi

	procd_open_instance

	procd_set_param command $PROG

	procd_set_param file $SWANCTL_CONF_FILE
	procd_append_param file /etc/swanctl/conf.d/*.conf
	procd_append_param file $STRONGSWAN_CONF_FILE

	procd_set_param respawn

	procd_close_instance
}
